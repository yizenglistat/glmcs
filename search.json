[{"path":"https://yizenglistat.github.io/glmcs/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Yizeng Li. Author, maintainer. Wei Pan. Author.","code":""},{"path":"https://yizenglistat.github.io/glmcs/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Li Y, Pan W (2025). glmcs: Generalized Linear Models Confident Sets. R package version 0.1.0, https://github.com/yizenglistat/glmcs.","code":"@Manual{,   title = {glmcs: Generalized Linear Models with Confident Sets},   author = {Yizeng Li and Wei Pan},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/yizenglistat/glmcs}, }"},{"path":[]},{"path":"https://yizenglistat.github.io/glmcs/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Generalized Linear Models with Confident Sets","text":"glmcs implements likelihood-based additive single-effect regression (LASER) via block-coordinate ascent algorithm, provides confidence sets (CSs) variable selection uncertainty quantification. Key features: - Robust variable selection high multicollinearity - Confident sets capture posterior uncertainty variable inclusion - Flexible modeling: Gaussian, generalized linear (e.g. logistic, Poisson), Cox regression - High/Scalable performance via C++ (Rcpp & Armadillo) backend - Extensions: applicable general likelihood-based regression variable selection problems","code":""},{"path":"https://yizenglistat.github.io/glmcs/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generalized Linear Models with Confident Sets","text":"Development version GitHub:","code":"# remotes if (!requireNamespace(\"remotes\", quietly = TRUE)) install.packages(\"remotes\") remotes::install_github(\"yizenglistat/glmcs\")"},{"path":"https://yizenglistat.github.io/glmcs/index.html","id":"demo","dir":"","previous_headings":"","what":"Demo","title":"Generalized Linear Models with Confident Sets","text":"Figure 1: Variable selection visualization showing two confidence sets. Point sizes reflect confidence values; larger points indicate higher confidence. Points color belong confidence set.","code":"library(glmcs)  SEED <- 42  set.seed(SEED)  n <- 500; p <- 5  # Create correlation matrix with specific structure cor_matrix <- matrix(0, nrow = p, ncol = p) diag(cor_matrix) <- 1  # X1, X2, X3 highly correlated cor_matrix[1:3, 1:3] <- 0.95 diag(cor_matrix[1:3, 1:3]) <- 1  # X4, X5 highly correlated cor_matrix[4:5, 4:5] <- 0.95 diag(cor_matrix[4:5, 4:5]) <- 1  # Generate multivariate normal data X <- MASS::mvrnorm(n = n, mu = rep(0, p), Sigma = cor_matrix)  # coefficents theta <- rep(0, p);  theta[c(2, 5)] <- 1 prob <- plogis(0.5 + X %*% theta) y <- rbinom(n, 1, prob)  res <- glmcs(X           = X,               y           = y,              family      = binomial(\"logit\"),              L           = 10L,              coverage    = 0.95,              seed        = SEED)  print(res$cs) # $sets # $sets$cs1 # [1] 5  # $sets$cs2 # [1] 1 2   # $claimed # [1] 0.9905875 0.9851817"},{"path":"https://yizenglistat.github.io/glmcs/index.html","id":"main-functions","dir":"","previous_headings":"","what":"Main Functions","title":"Generalized Linear Models with Confident Sets","text":"glmcs(X, y, family, L, coverage, ...) End‐‐end wrapper: fits LASER model, variable selection, builds confidence sets. get_laser_fit() Core fitting engine (C++): returns raw posterior model probabilities, point estimates, p-values, etc. get_included(), get_cs() Select significant single‐effect components construct confidence sets purity filtering (applicable). get_glm_fit(), get_cox_fit(), null_glm_fit(), null_cox_fit() Fast univariate fits (Gaussian, Binomial, Poisson, Gamma, inverse-Gaussian, Cox) via closed-form IRLS. Low-level utilities: get_loglike(), update_intercept(), update_dispersion(), get_purity(), etc.","code":""},{"path":[]},{"path":"https://yizenglistat.github.io/glmcs/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Generalized Linear Models with Confident Sets","text":"GPL-3 | © 2025 Yizeng Li & Wei Pan “Extensible generalizable variable selection confidence high‐dimensional, multicollinear settings—glmcs delivers statistical rigor computational efficiency.”","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/additive_effect_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Likelihood-based Additive Single-Effect Regression (LASER) Model — additive_effect_fit","title":"Fit Likelihood-based Additive Single-Effect Regression (LASER) Model — additive_effect_fit","text":"Fits LASER model, representing coefficient vector sum L sparse \"single effects.\"  iteration, cyclically applies single_effect_fit update one effect holding others fixed, updates intercept (dispersion, applicable), convergence max_iter reached.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/additive_effect_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Likelihood-based Additive Single-Effect Regression (LASER) Model — additive_effect_fit","text":"X Numeric matrix (n × p) predictors. y Response: GLMs: numeric vector length n. Cox: numeric matrix 2 columns (time, status) n rows. L Integer; number single effects include (set min(10, L)). family stats::family object (e.g. gaussian(), binomial(), poisson()) Cox family list family = \"cox\". standardize Logical: TRUE, center scale predictor column fitting (default: TRUE). ties Character: ties method Cox partial likelihood (\"efron\" \"breslow\", default: \"efron\"). lambda Numeric penalty weight; ≤ 0, defaults \\(\\sqrt{2\\log(n)/n}\\) (default: 0.0). tau Numeric truncation parameter; ≤ 0, defaults 0.5 (default: 0.5). null_threshold Numeric threshold estimated coefficient set zero (default: 1e-6). tol Numeric; convergence tolerance change expected log-likelihood (default: 5e-2). max_iter Integer; maximum number coordinate-ascent iterations (default: 100).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/additive_effect_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Likelihood-based Additive Single-Effect Regression (LASER) Model — additive_effect_fit","text":"list components: niter Number iterations performed. loglik p × L matrix univariate log-likelihoods. expect_loglik Vector length niter giving expected log-likelihood iteration. final_loglik Expected log-likelihood convergence. intercept Estimated intercept term. dispersion Estimated dispersion parameter (Gaussian/Gamma). theta p × L matrix fitted single-effect coefficients. pmp p × L matrix posterior model probabilities. bic p × L matrix BIC values. bic_diff p × L matrix BIC differences null. bf p × L matrix Bayes factors. expect_variance Length-L vector PMP-weighted variances. kept Logical vector length L; TRUE effects retained. elapsed_time Numeric; total computation time seconds.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/additive_effect_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Likelihood-based Additive Single-Effect Regression (LASER) Model — additive_effect_fit","text":"","code":"if (FALSE) { # \\dontrun{ # Gaussian example with 5 effects X <- matrix(rnorm(100*20), 100, 20) y <- rnorm(100) res <- additive_effect_fit(X, y, L = 5, family = gaussian())  # Cox regression example times  <- rexp(100) status <- rbinom(100, 1, 0.5) y_cox  <- cbind(times, status) res_cox <- additive_effect_fit(X, y_cox, L = 3,                                family = list(family = \"cox\"),                                ties = \"breslow\") } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/confidence_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Confidence Sets from Posterior Model Probabilities — confidence_set","title":"Construct Confidence Sets from Posterior Model Probabilities — confidence_set","text":"latent effect (column) posterior model probability matrix pmp, select smallest set variables whose cumulative probability reaches least coverage.  Optionally filter sets whose minimum absolute pairwise correlation (Rmat) cor_threshold, remove duplicates.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/confidence_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Confidence Sets from Posterior Model Probabilities — confidence_set","text":"","code":"confidence_set(pmp, kept, coverage = 0.95, Rmat = NULL, cor_threshold = 0.5)"},{"path":"https://yizenglistat.github.io/glmcs/reference/confidence_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Confidence Sets from Posterior Model Probabilities — confidence_set","text":"pmp Numeric matrix dimension \\(p \\times L\\), column sums 1 contains posterior inclusion probabilities variable effect. kept Logical vector length \\(L\\), indicating effects (columns) process. coverage Numeric scalar [0,1], target cumulative probability confidence set. Defaults 0.95. Rmat Optional \\(p \\times p\\) numeric correlation matrix predictors. supplied, set whose minimum -diagonal absolute correlation cor_threshold discarded.  Defaults NULL. cor_threshold Numeric scalar [0,1], minimum absolute correlation allowed within set pass correlation filter.  Defaults 0.5.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/confidence_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Confidence Sets from Posterior Model Probabilities — confidence_set","text":"list components: sets named list integer vectors.  element cs1, cs2, … confidence set variable indices achieves target coverage.  sets survive filters, sets NULL. claimed Numeric vector actual cumulative probabilities (\"claimed coverage\") returned set.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/confidence_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Confidence Sets from Posterior Model Probabilities — confidence_set","text":"","code":"# Simple two-effect example pmp <- matrix(c(0.6, 0.3, 0.1,                 0.2, 0.5, 0.3),               nrow = 3, byrow = FALSE) kept <- c(TRUE, TRUE) cs <- confidence_set(pmp, kept)  # With a correlation filter Rmat <- cor(matrix(rnorm(9), nrow = 3)) cs2 <- confidence_set(pmp, kept, coverage = 0.8, Rmat = Rmat, cor_threshold = 0.2)"},{"path":"https://yizenglistat.github.io/glmcs/reference/cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Cox Proportional Hazards ","title":"Cox Proportional Hazards ","text":"Creates family object univariate Cox regression, compatible GLM‐style interfaces.  log link supported, yielding usual Cox partial‐likelihood formulation.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/cox.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cox Proportional Hazards ","text":"","code":"cox(link = \"log\")"},{"path":"https://yizenglistat.github.io/glmcs/reference/cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cox Proportional Hazards ","text":"link Character string; link function Cox model.  \"log\" supported (default).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cox Proportional Hazards ","text":"family object (list class \"family\") containing: family Always \"cox\". link Link name, \"log\". linkfun Function transforming mu eta. linkinv Inverse link, mapping eta mu. mu.eta Derivative linkinv. variance Variance function (returns 1). dev.resids Deviance residuals (zeros). aic AIC placeholder (returns -2). validmu, valideta Validation functions (always TRUE). dispersion Always 1.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cox Proportional Hazards ","text":"\"family\" object provides minimal set functions required use IRLS‐based routines log-likelihood calculations: linkfun linkinv implement log link. mu.eta provides derivative inverse link. variance, dev.resids, aic placeholders (used Cox needed compatibility).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cox Proportional Hazards ","text":"","code":"# Create the Cox family object fam <- cox(link = \"log\") stopifnot(fam$family == \"cox\") # Check that linkinv(exp(eta)) == exp(eta) eta <- c(0, 1, -1) all.equal(fam$linkinv(eta), exp(eta)) #> [1] TRUE"},{"path":"https://yizenglistat.github.io/glmcs/reference/generate.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Synthetic Data for Benchmark Simulations — generate","title":"Generate Synthetic Data for Benchmark Simulations — generate","text":"Creates design matrix X controlled correlation structure simulates response y according specified family.  Supports Gaussian, Binomial, Poisson, Gamma GLMs, Cox survival data exponential baseline hazard.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/generate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Synthetic Data for Benchmark Simulations — generate","text":"","code":"generate(   n = 600,   theta = c(1, 0),   intercept = 0,   settings = c(\"ex1\", \"ex2\", \"ex3\"),   rho = 0.9,   dispersion = 1,   family = gaussian(),   censoring_rate = 0.3,   baseline_hazard = 1 )"},{"path":"https://yizenglistat.github.io/glmcs/reference/generate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Synthetic Data for Benchmark Simulations — generate","text":"n Integer; number observations (default: 600). theta Numeric vector true coefficients (length p). intercept Numeric; true intercept term (default: 0). settings Character; correlation pattern: \"ex1\": p variables equally correlated. \"ex2\": first 5×5 block correlated, others independent. \"ex3\": two p/2 × p/2 blocks correlated. Default: c(\"ex1\",\"ex2\",\"ex3\"). rho Numeric [0,1]; within-block correlation (default: 0.9). dispersion Numeric; dispersion Gaussian/Gamma (default: 1). family family object (e.g. gaussian(), binomial(), poisson(), Gamma()) string \"cox\" survival data (default: gaussian()). censoring_rate Numeric [0,1]; fraction censored Cox models (default: 0.3). baseline_hazard Numeric function; constant hazard rate Cox, hazard function provided (default: 1).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/generate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Synthetic Data for Benchmark Simulations — generate","text":"list components: X n × p design matrix specified correlation. y Response: Numeric vector length n (GLMs). n × 2 matrix (time, status) (Cox). eta Linear predictor intercept + X %*% theta.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/generate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Synthetic Data for Benchmark Simulations — generate","text":"","code":"if (FALSE) { # \\dontrun{ # Gaussian data, p = 2 dat1 <- generate(n = 100, theta = c(1, 0), settings = \"ex1\",                  family = gaussian(), dispersion = 2)  # Binomial data with probit link dat2 <- generate(n = 200, theta = c(0.5, -0.5),                  family = binomial(link = \"probit\"),                  settings = \"ex2\", rho = 0.7)  # Cox survival data dat3 <- generate(n = 150, theta = c(1, 1, 0),                  settings = \"ex3\", family = \"cox\",                  censoring_rate = 0.2, baseline_hazard = 0.05) } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/glmcs-package.html","id":null,"dir":"Reference","previous_headings":"","what":"glmcs: Generalized Linear Models with Confident Sets — glmcs-package","title":"glmcs: Generalized Linear Models with Confident Sets — glmcs-package","text":"Implements likelihood-based additive single-effect regression (LASER) via blockwise coordinate ascent algorithm, providing confident sets variable selection uncertainty quantification. Features include robust variable selection high multicollinearity, confident sets capture posterior uncertainty variable inclusion, flexible modeling linear, generalized linear, Cox regression, high performance via C++ backend, configurable parameters number effects, coverage, convergence tolerance.","code":""},{"path":[]},{"path":"https://yizenglistat.github.io/glmcs/reference/glmcs-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"glmcs: Generalized Linear Models with Confident Sets — glmcs-package","text":"Maintainer: Yizeng Li yizenglistat@gmail.com Authors: Wei Pan panxx014@umn.edu","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/glmcs.html","id":null,"dir":"Reference","previous_headings":"","what":"glmcs: Generalized Linear Model with Confidence Sets — glmcs","title":"glmcs: Generalized Linear Model with Confidence Sets — glmcs","text":"Fits sparse likelihood-based additive single-effect (LASER) model using iteratively blockwise coordinate ascent alogirthm across various generalized linear model families. Supports Gaussian, binomial, Poisson, Gamma GLMs, Cox regression models.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/glmcs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"glmcs: Generalized Linear Model with Confidence Sets — glmcs","text":"","code":"glmcs(   X,   y,   L = 10L,   family = gaussian(),   coverage = 0.95,   cor_threshold = 0.5,   standardize = TRUE,   null_threshold = 1e-06,   tol = 0.05,   ties = c(\"efron\", \"breslow\"),   lambda = 0,   tau = 0.5,   max_iter = 100L,   seed = NULL )"},{"path":"https://yizenglistat.github.io/glmcs/reference/glmcs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"glmcs: Generalized Linear Model with Confidence Sets — glmcs","text":"X Numeric matrix vector predictors. vector, converted matrix. y Response variable (vector GLMs, matrix time status Cox regression). L Integer specifying number components fit (must least 1 less ncol(X)). family family object specifying model type (e.g., gaussian(), binomial(), poisson(), Gamma(), cox()). coverage Numeric [0,1] specifying target coverage probability credible sets (default: 0.95). cor_threshold Numeric [0,1] specifying minimum absolute correlation variables within credible set (default: 0.5). standardize Logical indicating whether standardize predictors (default: TRUE). null_threshold Numeric specifying threshold coefficients set zero (default: 1e-6). tol Numeric specifying convergence tolerance log-likelihood (default: 5e-2). ties String specifying method handling tied events Cox regression: \"efron\" (default) \"breslow\". lambda Numeric specifying convergence tolerance log-likelihood (default: 5e-2). tau Numeric specifying convergence tolerance log-likelihood (default: 5e-2). max_iter Integer specifying maximum number fitting iterations (default: 100). seed Integer seed reproducibility (default: NULL).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/glmcs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"glmcs: Generalized Linear Model with Confidence Sets — glmcs","text":"list components: theta Matrix estimated coefficients (p L) intercept Estimated intercept (NULL Cox regression) pmp Matrix posterior model probabilities (p L) dispersion Estimated dispersion parameter loglik Matrix log-likelihoods (p L) cs Credible sets obtained posterior probabilities niter Number iterations performed","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/is_covered.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Whether True Actives Are Covered by Confidence Sets — is_covered","title":"Check Whether True Actives Are Covered by Confidence Sets — is_covered","text":"Determines true active variables included least one provided confidence sets. Returns TRUE every element true_active appears union sets, FALSE otherwise.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/is_covered.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Whether True Actives Are Covered by Confidence Sets — is_covered","text":"","code":"is_covered(confidence_sets, true_active)"},{"path":"https://yizenglistat.github.io/glmcs/reference/is_covered.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Whether True Actives Are Covered by Confidence Sets — is_covered","text":"confidence_sets list integer vectors, representing confidence set selected variable indices. single vector provided, coerced list length one. true_active Integer vector true active variable indices.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/is_covered.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Whether True Actives Are Covered by Confidence Sets — is_covered","text":"Logical scalar. TRUE elements true_active contained union confidence_sets, FALSE otherwise.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/is_covered.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Whether True Actives Are Covered by Confidence Sets — is_covered","text":"","code":"# Single set, true actives 1 and 3 are both covered is_covered(confidence_sets = c(1, 3, 5), true_active = c(1, 3)) #> [1] TRUE  # Multiple sets, true active 2 appears in one of them sets <- list(cs1 = c(1,4), cs2 = c(2,5), cs3 = c(3)) is_covered(confidence_sets = sets, true_active = c(2,3)) #> [1] TRUE  # Not covered if any true active is missing is_covered(confidence_sets = list(c(1,4)), true_active = c(1,2)) #> [1] FALSE"},{"path":"https://yizenglistat.github.io/glmcs/reference/single_effect_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Single‐Effect Fit for GLM or Cox with Optional Truncated‐L1 Penalty — single_effect_fit","title":"Compute Single‐Effect Fit for GLM or Cox with Optional Truncated‐L1 Penalty — single_effect_fit","text":"Applies single‐effect model column predictor matrix using either GLM (via IRLS + truncated‐L1) Cox partial likelihood (via penalized IRLS).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/single_effect_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Single‐Effect Fit for GLM or Cox with Optional Truncated‐L1 Penalty — single_effect_fit","text":"X Numeric matrix (n × p) predictors. column fit separately. y Response: GLMs: numeric vector length n. Cox: numeric matrix 2 columns (time, status) n rows. family stats::family object (e.g. gaussian(), binomial(), poisson()) Cox family list family = \"cox\". offset Numeric scalar vector (length n) giving linear predictor offset (default: 0). standardize Logical: TRUE, center scale predictor column fitting (default: TRUE). ties Character: ties method Cox partial likelihood (\"efron\" \"breslow\", default: \"efron\"). lambda Numeric penalty weight; ≤ 0, defaults \\(\\sqrt{2\\log(n)/n}\\) (default: 0.0). tau Numeric truncation parameter; ≤ 0, defaults 1.0 (default: 1.0). null_threshold Numeric threshold estimated coefficient set zero (default: 1e-6).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/single_effect_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Single‐Effect Fit for GLM or Cox with Optional Truncated‐L1 Penalty — single_effect_fit","text":"list length p, element list components: theta Estimated coefficient predictor. loglik Unpenalized log‐likelihood fitted coefficient. bic Bayesian Information Criterion: \\(-2*logLik + 2\\log(n)\\).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/single_effect_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Single‐Effect Fit for GLM or Cox with Optional Truncated‐L1 Penalty — single_effect_fit","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(123) n <- 80; p <- 3 X <- matrix(rnorm(n*p), n, p) # Gaussian example y_gauss <- X[,1] * 1.2 + rnorm(n) res_glm <- single_effect_fit(X, y_gauss, family = gaussian())  # Cox example times <- rexp(n, rate = exp(0.5 * X[,2])) status <- rbinom(n, 1, 0.7) y_cox <- cbind(time=times, status=status) res_cox <- single_effect_fit(X, y_cox, family = list(family=\"cox\")) } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_coef.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Coefficient Estimates Across Simulations — summarize_coef","title":"Summarize Coefficient Estimates Across Simulations — summarize_coef","text":"Given matrix simulated coefficient estimates true coefficient vector, compute per‐variable summary statistics: empirical mean standard deviation estimates, alongside true value.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_coef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Coefficient Estimates Across Simulations — summarize_coef","text":"","code":"summarize_coef(sims_coef, true_theta, decimal = 2)"},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_coef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Coefficient Estimates Across Simulations — summarize_coef","text":"sims_coef Numeric matrix dimension \\(p \\times n_{\\text{sim}}\\), row corresponds one predictor column simulation replicate. true_theta Numeric vector length \\(p\\), containing true coefficient values predictor. decimal Nonnegative integer.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_coef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Coefficient Estimates Across Simulations — summarize_coef","text":"data.frame columns: true true coefficient values, true_theta. mean Row‐wise mean sims_coef, average estimated coefficient. ssd Row‐wise standard deviation sims_coef, empirical sampling variability.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_coef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Coefficient Estimates Across Simulations — summarize_coef","text":"","code":"# Suppose we ran 100 simulations for 3 predictors set.seed(42) true_theta <- c(1.5, 0, -2) sims_coef  <- matrix(rnorm(3 * 100, mean = rep(true_theta, each = 100), sd = 0.3),                      nrow = 3, byrow = TRUE) summarize_coef(sims_coef, true_theta) #>   true  mean  ssd #> 1  1.5  1.51 0.31 #> 2  0.0 -0.03 0.27 #> 3 -2.0 -2.00 0.31"},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_cs.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Multi‐Set Confidence Regions Across Simulations — summarize_cs","title":"Summarize Multi‐Set Confidence Regions Across Simulations — summarize_cs","text":"Given list simulation results run may return multiple confidence sets (e.g. cs1, cs2, …), function enumerates distinct patterns sets, counts often occurs, computes fraction simulations, tests whether union sets pattern covers true active variables.  Within pattern, individual sets ordered first size (smallest first), lexicographically indices.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_cs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Multi‐Set Confidence Regions Across Simulations — summarize_cs","text":"","code":"summarize_cs(cs_list, true_active, decimal = 2)"},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_cs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Multi‐Set Confidence Regions Across Simulations — summarize_cs","text":"cs_list List length n_sims. element either: R list (e.g. list(cs1=..., cs2=..., …)) integer vectors, NULL empty list, meaning confidence sets returned. inner integer vector holds indices single confidence set. true_active Integer vector true active variable indices. decimal Nonnegative integer.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/summarize_cs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Multi‐Set Confidence Regions Across Simulations — summarize_cs","text":"data.frame columns: set Character: unique simulation pattern rendered comma‐separated set literals, e.g.\\  \"{1,4}, {2,3}\".  empty pattern shown \"{}\". count Integer: number simulations produced exactly pattern sets. percent Numeric: count divided n_sims. cover Logical: TRUE union sets pattern contains every element true_active. Rows sorted descending order count.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_fit.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Univariate Fit with Optional Truncated‐L1 Penalty — univariate_fit","title":"Compute Univariate Fit with Optional Truncated‐L1 Penalty — univariate_fit","text":"Fits single‐covariate model (GLM Cox) optional standardization truncated‐L1 penalty coefficient.  GLMs uses IRLS capped‐L1 update; Cox uses penalized IRLS partial likelihood.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_fit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Univariate Fit with Optional Truncated‐L1 Penalty — univariate_fit","text":"x Numeric vector covariate values (length n); scalar expands zeros. y Response: GLMs: numeric vector length n. Cox: numeric matrix 2 columns (time, status) n rows. family stats::family object (e.g. gaussian(), binomial(), poisson()) Cox family list family = \"cox\". offset Numeric scalar vector (length n) giving linear predictor offset (default: 0). standardize Logical: TRUE, center scale x fitting (default: TRUE). ties Character: ties method Cox partial likelihood (\"efron\" \"breslow\", default: \"efron\"). lambda Numeric penalty weight; NULL ≤ 0, defaults \\(\\sqrt{2\\log(n)/n}\\). tau Numeric truncation parameter; NULL ≤ 0, defaults 0.5. null_threshold Numeric threshold final theta set zero (default: 1e-6). max_iter Integer: maximum number IRLS iterations (default: 25). tol Numeric convergence tolerance theta updates (default: 1e-8).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_fit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Univariate Fit with Optional Truncated‐L1 Penalty — univariate_fit","text":"list elements: theta Estimated coefficient (undoing standardization). loglik Unpenalized log-likelihood estimated theta. bic Bayesian Information Criterion: \\(-2*loglik + 2\\log(n)\\).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_fit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Univariate Fit with Optional Truncated‐L1 Penalty — univariate_fit","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(101) n <- 50 x <- rnorm(n) # Gaussian GLM y_gauss <- 1.5*x + rnorm(n) res1 <- univariate_fit(x, y_gauss, family = gaussian(), offset = 0)  # Cox example times  <- rexp(n, rate = exp(0.7*x)) status <- rbinom(n, 1, 0.6) y_cox  <- cbind(time=times, status=status) res2 <- univariate_fit(x, y_cox, family = list(family=\"cox\")) } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Univariate Cox Model via Iteratively Reweighted Least Squares (IRLS) — univariate_irls_cox","title":"Estimate Univariate Cox Model via Iteratively Reweighted Least Squares (IRLS) — univariate_irls_cox","text":"Fits univariate Cox proportional hazards model maximizing partial log-likelihood using Iteratively Reweighted Least Squares (IRLS) approach. Supports Breslow Efron approximations handling ties.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Univariate Cox Model via Iteratively Reweighted Least Squares (IRLS) — univariate_irls_cox","text":"x Numeric vector length n: covariate values. y Numeric matrix shape n × 2, : y[,1] observed time y[,2] event indicator (1 = event, 0 = censored) offset Numeric scalar vector length n. Optional offset linear predictor. ties Character string specifying method handle ties: \"breslow\" (default) \"efron\". lambda Numeric penalty weight; ≤0 defaults \\(\\sqrt{2\\log(n)/n}\\). tau Numeric truncation parameter; ≤0 uses grid {1/n,…,5/n} n≤500 1/n otherwise. max_iter Integer: maximum number IRLS iterations. Default 25. tol Numeric: convergence tolerance parameter change. Default 1e-8.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Univariate Cox Model via Iteratively Reweighted Least Squares (IRLS) — univariate_irls_cox","text":"numeric scalar representing estimated regression coefficient theta.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Univariate Cox Model via Iteratively Reweighted Least Squares (IRLS) — univariate_irls_cox","text":"function starts initial coefficient value 0 updates slope estimate using Newton-Raphson iterations convergence reaching maximum number iterations. linear predictor lp = offset + theta * x. score function observed information used update estimate.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Univariate Cox Model via Iteratively Reweighted Least Squares (IRLS) — univariate_irls_cox","text":"","code":"if (FALSE) { # \\dontrun{ x <- c(1, 2, 3, 4) y <- matrix(c(4,1, 1,1, 3,0, 2,1), ncol = 2, byrow = TRUE) univariate_irls_cox(x, y, offset = 0, ties = \"efron\", max_iter = 50, tol = 1e-6) } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_glm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Truncated‐L1 IRLS Estimate for Univariate GLM — univariate_irls_glm","title":"Compute Truncated‐L1 IRLS Estimate for Univariate GLM — univariate_irls_glm","text":"Fits single‐covariate GLM using IRLS truncated‐L1 penalty. Solves: $$\\min_\\theta\\;-\\ell(\\theta) \\;+\\;\\lambda\\,\\min\\bigl(1,|\\theta|/\\tau\\bigr)$$ via iteratively reweighted least squares, closed‐form capped‐L1 update step.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_glm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Truncated‐L1 IRLS Estimate for Univariate GLM — univariate_irls_glm","text":"x Numeric vector covariates (length n). y Numeric response vector (length n). family stats::family object (e.g. gaussian(), binomial(), poisson()). offset Numeric scalar vector (length n) giving linear predictor offset. lambda Numeric penalty weight; ≤0 defaults \\(\\sqrt{2\\log(n)/n}\\). tau Numeric truncation parameter; ≤0 uses grid {1/n,…,5/n} n≤500 1/n otherwise. max_iter Integer. Maximum number IRLS iterations. tol Numeric convergence tolerance θ.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_glm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Truncated‐L1 IRLS Estimate for Univariate GLM — univariate_irls_glm","text":"Numeric scalar: estimated coefficient \\(\\hat\\theta\\).","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_irls_glm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Truncated‐L1 IRLS Estimate for Univariate GLM — univariate_irls_glm","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(42) n <- 100 x <- rnorm(n) # Gaussian example y <- 2*x + rnorm(n) univariate_irls_glm(x, y, gaussian(), offset=0,                     lambda=0, tau=0, max_iter=25, tol=1e-8) } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Univariate Log-Likelihood for GLM or Cox Model — univariate_loglik","title":"Compute Univariate Log-Likelihood for GLM or Cox Model — univariate_loglik","text":"Calculates log-likelihood single covariate effect either generalized linear model (GLM) family Cox proportional hazards model.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Univariate Log-Likelihood for GLM or Cox Model — univariate_loglik","text":"x Numeric vector length n: covariate values. y GLMs: numeric vector length n; Cox: numeric matrix two columns (time, status) n rows. family GLM family object (e.g. gaussian(), binomial(), poisson()) Cox family list element family=\"cox\". theta Numeric scalar: coefficient evaluate log-likelihood. offset Numeric scalar vector length n: offset linear predictor. ties Character string: tie-handling method Cox partial likelihood; one \"efron\" \"breslow\".","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Univariate Log-Likelihood for GLM or Cox Model — univariate_loglik","text":"numeric scalar giving log-likelihood univariate fit.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Univariate Log-Likelihood for GLM or Cox Model — univariate_loglik","text":"","code":"if (FALSE) { # \\dontrun{ # Gaussian example x <- rnorm(100) y <- 2 * x + rnorm(100) univariate_loglik(x, y, family = gaussian(), theta = 2, offset = 0)  # Binomial example x <- rnorm(200) eta <- -1 + 1.5 * x p <- plogis(eta) y <- rbinom(200, 1, p) univariate_loglik(x, y, family = binomial(link = \"logit\"),                   theta = 1.5, offset = 0)  # Cox example x <- rnorm(50) times <- rexp(50) status <- rbinom(50, 1, 0.5) ymat <- cbind(times, status) univariate_loglik(x, ymat, family = list(family = \"cox\"),                   theta = 0.5, offset = 0, ties = \"efron\") } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik_cox.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Log-Likelihood for Univariate Cox Model — univariate_loglik_cox","title":"Compute Log-Likelihood for Univariate Cox Model — univariate_loglik_cox","text":"Computes partial log-likelihood univariate Cox proportional hazards model. Handles ties using either Breslow Efron approximation.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik_cox.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Log-Likelihood for Univariate Cox Model — univariate_loglik_cox","text":"x Numeric vector length n: covariate values individual. y Numeric matrix shape n × 2, : - y[,1] contains event/censoring times - y[,2] contains event status (1 = event, 0 = censored) theta Numeric scalar: coefficient evaluate log-likelihood . offset Numeric vector length n, scalar. Optional offset linear predictor. ties Character string: tie-handling method. Must either \"breslow\" \"efron\".","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik_cox.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Log-Likelihood for Univariate Cox Model — univariate_loglik_cox","text":"Numeric scalar: partial log-likelihood value.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik_cox.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Log-Likelihood for Univariate Cox Model — univariate_loglik_cox","text":"function computes linear predictor : lp = offset + theta * x. partial log-likelihood calculated using either Breslow Efron method handling tied event times.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/univariate_loglik_cox.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Log-Likelihood for Univariate Cox Model — univariate_loglik_cox","text":"","code":"if (FALSE) { # \\dontrun{ x <- c(1, 2, 3, 4) y <- matrix(c(4,1, 1,1, 3,0, 2,1), ncol = 2, byrow = TRUE) univariate_loglik_cox(x, y, offset = 0, theta = 0.5, ties = \"efron\") } # }"},{"path":"https://yizenglistat.github.io/glmcs/reference/update_dispersion.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Dispersion for GLM Family — update_dispersion","title":"Estimate Dispersion for GLM Family — update_dispersion","text":"Computes dispersion parameter Generalized Linear Model (GLM) using either Pearson residual method deviance-based approach.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/update_dispersion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Dispersion for GLM Family — update_dispersion","text":"y Numeric response vector length n. family GLM family object (e.g., gaussian(), poisson(), Gamma()). offset Numeric vector scalar representing linear predictor eta; defaults 0. approach Character string: either \"pearson\" \"deviance\".","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/update_dispersion.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Dispersion for GLM Family — update_dispersion","text":"numeric scalar representing estimated dispersion.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/update_dispersion.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Dispersion for GLM Family — update_dispersion","text":"function supports family object stats::family(), gaussian(), poisson(), Gamma(), etc. linear predictor given offset, inverse link function applied compute mean response mu. approach = \"pearson\", computes: $$ \\phi = \\frac{1}{n - p} \\sum_i \\left( \\frac{y_i - \\mu_i}{\\sqrt{\\text{var}(\\mu_i)}} \\right)^2 $$ approach = \"deviance\", computes: $$ \\phi = \\frac{1}{n - p} \\sum_i \\text{dev}_i $$ dev_i deviance residuals.","code":""},{"path":"https://yizenglistat.github.io/glmcs/reference/update_dispersion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Dispersion for GLM Family — update_dispersion","text":"","code":"if (FALSE) { # \\dontrun{ y <- rgamma(100, shape = 2, rate = 2) offset <- rep(log(mean(y)), 100) update_dispersion(y, Gamma(), offset = offset, approach = \"pearson\") } # }"}]
