% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/benchmark.R
\name{run_ex1}
\alias{run_ex1}
\title{Run the "Example 1" Benchmark Scenario}
\usage{
run_ex1(
  n_sims = 50L,
  n = 600L,
  p = 2L,
  L = 10L,
  family = gaussian(),
  rho = 0.9,
  intercept = -1,
  dispersion = 9,
  censoring_rate = 0.3,
  coverage = 0.95,
  methods = c("glmcs", "susie"),
  standardize = TRUE,
  ties = "efron",
  algorithm = "greedy",
  max_iter = 100L,
  step_size = 1,
  tol = 1,
  min_abs_corr = 0,
  parallel = FALSE,
  cores = parallel::detectCores() - 1L,
  save_path = NULL,
  save_freq = 50L,
  seed = 42L
)
}
\arguments{
\item{n_sims}{Integer. Number of simulation replicates. Default: 50.}

\item{n}{Integer. Number of observations per simulation. Default: 600.}

\item{p}{Integer. Number of predictors. Default: 2 (minimum for Example 1).}

\item{L}{Integer. Number of single-effect components. Default: 10.}

\item{family}{GLM family object or "cox". Default: gaussian().}

\item{rho}{Numeric in (0,1). Correlation coefficient for the two-predictor scenario.
Default: 0.9.}

\item{intercept}{Numeric. True intercept for data generation. Default: -1.}

\item{dispersion}{Numeric. Dispersion parameter for GLMs. Default: 9.}

\item{censoring_rate}{Numeric in [0,1). Censoring rate for Cox models. Default: 0.3.}

\item{coverage}{Numeric in (0,1). Confidence set coverage level. Default: 0.95.}

\item{methods}{Character vector. Methods to benchmark. Default: c("glmcs", "susie").}

\item{standardize}{Logical. Whether to standardize predictors. Default: TRUE.}

\item{ties}{String. Cox tie-handling method: "efron" or "breslow". Default: "efron".}

\item{algorithm}{String. Update strategy: "greedy" or "shuffle". Default: "greedy".}

\item{max_iter}{Integer. Maximum iterations for optimization. Default: 100.}

\item{step_size}{Numeric. Step size for coordinate ascent. Default: 1.0.}

\item{tol}{Numeric. Convergence tolerance. Default: 1.}

\item{min_abs_corr}{Numeric. Minimum absolute correlation for purity filtering.
Default: 0.0.}

\item{parallel}{Logical. Whether to use parallel processing. Default: FALSE.}

\item{cores}{Integer. Number of cores for parallel processing.
Default: detectCores() - 1.}

\item{save_path}{Character or NULL. Path to save intermediate results. Default: NULL.}

\item{save_freq}{Integer. How often to save results. Default: 50.}

\item{seed}{Integer. Random seed for reproducibility. Default: 42.}
}
\value{
A list with components:
\describe{
\item{\code{coef_summary}}{List of coefficient recovery summaries per method.}
\item{\code{cs_summary}}{List of confidence set summaries per method.}
\item{\code{cover_summary}}{List of coverage rates per method.}
\item{\code{elapsed_time}}{Total benchmark execution time.}
\item{\code{methods_used}}{Character vector of methods used.}
}
}
\description{
A convenience wrapper for running the "Example 1" benchmark scenario with the GLMCS package.
This scenario tests variable selection methods on data with two highly correlated predictors,
where only one is truly active.
}
\details{
This function sets up and executes a complete benchmarking pipeline:
\enumerate{
\item Configures data generation with controlled correlation structure between predictors
\item Sets up method-specific parameters for GLMCS and (optionally) SuSiE
\item Runs multiple simulation replicates and collects performance metrics
\item Summarizes results on coefficient recovery and confidence set construction
}

The wrapper provides sensible defaults for all parameters while allowing full customization.
This makes it easy to run standardized benchmarks for comparing methods or testing
parameter sensitivity.
}
\examples{
\dontrun{
# Run default Gaussian benchmark
result <- run_ex1()

# Run custom benchmark with higher correlation
result <- run_ex1(
  n_sims = 100,
  n = 200,
  p = 10,
  rho = 0.95,  # Very high correlation
  methods = "glmcs"  # Only run GLMCS method
)

# Binomial regression benchmark
result_binary <- run_ex1(
  n_sims = 50,
  family = binomial(),
  parallel = TRUE,
  cores = 4
)

# Examine results
print(result$coef_summary$glmcs)
print(result$cover_summary)
}

}
\seealso{
\code{\link{benchmark}} for the core benchmarking engine,
\code{\link{simulate}} for data generation,
\code{\link{glmcs}} for the LASER model fitting
}
