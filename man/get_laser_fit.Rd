% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/internal.R
\name{get_laser_fit}
\alias{get_laser_fit}
\title{Fit LASER Model}
\arguments{
\item{X}{NumericMatrix (n × p) predictor matrix, where:
n = number of observations
p = number of predictors}

\item{y}{Response variable:
- For GLMs: numeric vector of length n
- For Cox: matrix with 2 columns (time, status)}

\item{family}{Model family specification:
- String: "cox", "gaussian", "binomial", "poisson", etc.
- List with element "family" or "name" containing family string}

\item{L}{Integer. Number of latent effects to include (default = 10).
If ≤ 0 or > p, automatically set to min(10, p).}

\item{standardize}{Logical. Whether to standardize predictors (default: TRUE).}

\item{ties}{String. Method for handling ties in Cox regression (default: "efron").}

\item{algorithm}{String. Update strategy: "cyclic", "shuffle", or "greedy" (default: "cyclic").}

\item{max_iter}{Integer. Maximum number of coordinate ascent iterations (default: 100).}

\item{step_size}{Double. Step size multiplier for updates (default: 1.0).
Values < 1 provide more conservative updates.}

\item{tol}{Double. Convergence tolerance on log-likelihood change (default: 1).}

\item{seed}{Integer or NULL. Random seed for reproducibility (default: NULL).
If NULL or NA, no seed is set.}
}
\value{
A list containing:
\itemize{
\item total_elapsed: Total execution time (seconds)
\item elapsed_per_ser: Average time per SER computation
\item n_iter: Number of iterations performed
\item final_loglike: Final model log-likelihood
\item intercept: Estimated intercept term
\item dispersion: Estimated dispersion parameter (for applicable GLMs)
\item theta: Matrix (p×L) of estimated coefficients for each effect
\item posterior: Matrix (p×L) of posterior probabilities
\item p_values: Matrix (p×L) of p-values
\item theta_hat: Vector (length p) of summed coefficients across effects
}
}
\description{
Fits the LASER model, which represents regression coefficients as a sum of L single-effects,
using blockwise coordinate ascent. The model supports both GLM families and Cox
regression and includes early stopping for efficient computation.
}
\details{
The LASER model represents the linear predictor as:

η = intercept + X * Σ(θᵢ)

where θᵢ are L sparse vectors of coefficients. The model is fitted using a block
coordinate ascent algorithm that iteratively updates each effect while holding
others constant. Three update strategies are available:
\enumerate{
\item "cyclic": Update each effect in order (default)
\item "shuffle": Update effects in random order each iteration
\item "greedy": Select the single effect update giving maximum improvement
}

For each update, the function uses single-effect regression (SER) to compute posterior
probabilities and coefficient estimates. The dispersion parameter and intercept are
updated after each complete iteration.
}
\note{
The "greedy" algorithm may be slower but often produces higher-quality models,
especially for smaller datasets. For large datasets, "cyclic" offers a good
balance of speed and quality.
}
\examples{
\dontrun{
# Gaussian example with 10 latent effects
X <- matrix(rnorm(100 * 20), 100, 20)
y <- rnorm(100)
laser_fit <- get_laser_fit(X, y, "gaussian", L = 5, algorithm = "cyclic")

# Binomial example with fewer effects
y_bin <- rbinom(100, 1, 0.5)
laser_bin <- get_laser_fit(X, y_bin, "binomial", L = 3, seed = 123)

# Cox regression example
time <- rexp(100)
status <- rbinom(100, 1, 0.5)
y_cox <- cbind(time, status)
laser_cox <- get_laser_fit(X, y_cox, "cox", L = 5, algorithm = "greedy")
}

}
\seealso{
\code{\link{get_ser_fit}} \code{\link{get_included}} \code{\link{get_cs}}
}
